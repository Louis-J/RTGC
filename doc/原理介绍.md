# RTGC - Realtime Tracing Garrbage Collection
一个用于C++的无环形引用问题的智能指针，可以安全的、高效的保证资源的及时回收及确定性析构
# 核心理念
* 堆内存的引用链是一个有向有环图结构，对象存货状态的唯一判别标准是: 是否能从栈对象直接或间接引用到
* GC类采用了定时扫描、活对象标记和整理的方法，保证了内存的释放，但并不能保证资源的析构，也不能保证资源的确定性及时析构
* 本算法采用了实时整理的办法，将有向有环图形式的引用链，通过做标记，转换为无循环引用的引用生成树(实际为由栈出发的生成森林，或由栈出发的有向无环图); 且当图修改时仅需局部更新，因此既保证了资源的确定性及时析构，又保证了性能
# 逻辑论证(单线程)
## 基本假设
* 所有堆和栈对象均符合RAII, 即可以通过构造函数分配资源, 通过析构函数释放资源
* 堆内存的引用链是一个有向有环图结构(V, E), V为对象集, E为对象间的指向关系集
* V可以分为栈对象集V1和堆对象集V2, V1对象由OS管理, 删除时系统自动调用析构; 所有对象均可以存储和获取属于V1还是V2
* V可以分为共享所有权对象集Va和唯一所有权对象集Vb, Va对象入度为>=0, Vb入度只为0或1; Va是V2子集(共享所有权只存在于边)
* E可以分为共享所有权边集Ea和唯一所有权对象边集Eb, 只有Ea中的边可以指向Va中的对象
* V中对象Vi是否存活的标准是: Vi属于V1, 或存在Vx属于V1且存在路径Vx->Vi

## RTGC条件
* 对象的构造函数视为不会死锁、线程安全和内存安全的原子操作, 析构函数中显式部分视为不会死锁、线程安全和内存安全的原子操作(由用户保证)
* 所有对象均可以存储自己属于V1还是V2
* Va中对象均可以存储和访问直接指向自己的边
* V中所有对象均可以通过自己出发的边向自己所连接的对象传递信息
直接指向自己的边自己属于向自己所引用的对象传递信息(使用RTGC的智能指针, 且所有函数)
* 定义内存安全状态为: V中所有对象均存活, 或V为空集

## 论证————删除
1. 假设当前为内存安全状态
n. 回到了内存安全状态，所有垃圾均被回收

## 论证————增加
1. 假设当前为内存安全状态
n. 回到了内存安全状态，所有垃圾均被回收



<!-- ## 论证
1. 对有向有环图可以 -->
# 具体设计
0. 用户需保证: 所有的函数均均为线程安全和内存安全的操作; 使用线程不安全的智能指针时, 不同线程的智能指针不能指向同一个对象; 使用线程安全的智能指针时, 一个智能指针本身只能被一个线程所使用
1. 堆内存对象一律为```ChainCore<T>```包裹，```ChainCore```内除T外还有记录了一个直接指向对象本身的智能指针地址```outr```(当多个指针指向时仅记录一个)
2. 智能指针为```ChainPtr<T>```类型，```ChainPtr```内除指向```ChainCore<T>```的裸指针```innr```外，还记录了同时指向同一个裸指针的其他“兄弟”智能指针；还有一个记录直接或间接指向本指针的的祖先栈地址```ance```(若本身在栈上，则```ance```值等于```this```)
3. 所有类都实现```LinkAnce```方法，用于传递和更新后续引用链；引用链中若有```ChainPtr<T>```智能指针，可根据```ance```值判断是否是强引用；引用链上所有节点都必有且仅有一个强引用
4. 当堆内存申请、修改指向时，若遇到强引用则用```LinkAnce```方法向下端传递，若遇到若引用则不需要向下传递；当堆内存释放时，若遇到强引用则尝试将强引用转移智能指针“兄弟”处并向下传递，若无“兄弟”则向下删除指向的堆内存
5. 实现了c++的编译期反射，```LinkAnce```方法无需手工编写，仅需在类内调用```RTGC_AutoChainLink```宏自动实现，且在编译期实现，对性能无影响
## STL集成
* 通过特化```RTGC_AutoChainLink```宏及相关方法，已处理集成```vector```等容器，可直接使用```vector<ChainPtr<T>>```类型；
* unsorted_map、unsorted_set、tuple、pair等类型尚未支持，对其他容器提供特化用例
## 线程安全
* 使用支持原子操作的全局变量数组，当处理某个栈对象时，提供互斥修改
* 通过原子操作，在实现引用链修改时保证线程安全。原子操作时间与同时处理统一节点的线程数正相关
# RTGC - Realtime Tracing Garrbage Collection
一个用于C++的无环形引用问题的智能指针，可以安全的、高效的保证资源的及时回收及确定性析构
# 核心理念
* 堆内存的引用链是一个有向有环图结构，对象存货状态的唯一判别标准是: 是否能从栈对象直接或间接引用到
* GC类采用了定时扫描、活对象标记和整理的方法，保证了内存的释放，但并不能保证资源的析构，也不能保证资源的确定性及时析构
* 本算法采用了实时整理的办法，将有向有环图形式的引用链，通过做标记，转换为无循环引用的引用生成树(实际为由栈出发的生成森林，或由栈出发的有向无环图); 且当图修改时仅需局部更新，因此既保证了资源的确定性及时析构，又保证了性能

# 基本假设
* 所有堆和栈对象均符合RAII, 即可以通过构造函数分配资源, 通过析构函数释放资源
* 堆内存的引用链是一个有向有环图结构(V, E), V为对象集, E为对象间的指向关系集
* V可以分为栈对象集V1和堆对象集V2, V1对象由OS管理, 删除时系统自动调用析构; 所有对象均可以存储和获取属于V1还是V2
* V可以分为共享所有权对象集Va和唯一所有权对象集Vb, Va对象入度为>=0, Vb入度只为0或1; Va是V2子集(共享所有权只存在于边)
* E可以分为共享所有权边集Ea和唯一所有权对象边集Eb, 只有Ea中的边可以指向Va中的对象
* V中对象Vi是否存活的标准是: Vi属于V1, 或存在Vx属于V1且存在路径Vx->Vi

# 实现过程描述
* 初始状态下, 强引用指针组成的图包含了所有存活节点, 且是一个森林(有向无环图), 其他的指针均为弱引用
* 在修改指针时使用写入屏障, 先判断此指针本身是否是弱引用, 若是则直接删除, 若是强引用则需要进行清理
* 清理过程需要对指针和对象进行标记, 分别为: 白色--初始状态, 不是垃圾; 黑色--可能是垃圾;
* 清理过程分为三步: 
  + 标记阶段1: 递归将所有强引用子对象和这些对象的所有指针标记为黑色
  + 标记阶段2: 递归对所有标记为黑色的对象进行"复活"操作, 就是找所有引用到此对象的指针中, 是否有白色指针, 若有则将此指针变为黑色强引用指针, 且递归标记此对象和此对象所有强引用子对象和这些对象的所有指针为白色
  + 清理阶段: 递归清扫所有黑色对象
* 清理之后, 所有对象均为白色, 且仍然符合初始状态的描述

# 伪代码描述
```c++
//假设: 
//指向同一对象指针之间通过.next和.prev组成链表,
//指针通过.innr指向实际对象, 通过.strong判断是强引用还是弱引用, 通过.color判断颜色
//对象通过.ptrs找到对象域中的所有指针, 通过.outer找到指向自己的强引用指针, 通过.color判断颜色

update_ptr(old, new_ptr) {
    update_ptr_to_null(old)
    update_nullptr(old, new_ptr)
}

update_ptr_to_null(ptr) {
    if(ptr.innr == null)
        return
    if(ptr.strong == false) { //弱引用
        ptr.innr = null
        ptr.prev.next = ptr.next
        ptr.next.prev = ptr.prev
    } else {
        update_ptr_to_null_strong(ptr)
    }
}

update_ptr_to_null_strong(ptr) {
    mark1_ptr(ptr) //标记1
    mark2_ptr(ptr) //标记2
    sweep_ptr(ptr) //清扫
}

mark1_ptr(ptr) {
    ptr.color = black
    if(ptr.strong)
        mark1_obj(ptr.innr)
}

mark1_obj(obj) {
    obj.color = black
    for(p in obj.ptrs)
        mark1_ptr(p)
}

mark2_ptr(ptr) {
    if(ptr == null)
        return
    if(ptr.strong)
        mark2_obj(ptr.innr)
}

mark2_obj(obj) {
    p = obj.outer.next
    while(p != obj.outer) {
        if(p.color == white) { //找到指向自己的白色引用
            //交换p到链表头
            op = obj.outer.prev
            on = obj.outer.next
            obj.outer.prev = p.prev
            obj.outer.next = p.next
            p.prev = op
            p.next = on

            //将p设为强引用
            p.strong = true
            obj.outer = p
        }
    }
    for(p in obj.ptrs)
        mark2_ptr(p)
}

sweep_ptr(ptr) {
    if(ptr == null)
        return
    if(ptr.strong && ptr.color == black)
        sweep_obj(ptr.innr)
    ptr = null
}

sweep_obj(obj) {
    for(p in obj.ptrs)
        sweep_ptr(p)
    deallocate(obj)
}

```

# 具体设计
0. 用户需保证: 所有的函数均均为线程安全和内存安全的操作; 使用线程不安全的智能指针时, 不同线程的智能指针不能指向同一个对象; 使用线程安全的智能指针时, 一个智能指针本身只能被一个线程所使用
1. 堆内存对象一律为```ChainCore<T>```包裹，```ChainCore```内除T外还有记录了一个直接指向对象本身的智能指针地址```outr```(当多个指针指向时仅记录一个)
2. 智能指针为```ChainPtr<T>```类型，```ChainPtr```内除指向```ChainCore<T>```的裸指针```innr```外，还记录了同时指向同一个裸指针的其他“兄弟”智能指针；还有一个记录直接或间接指向本指针的的祖先栈地址```ance```(若本身在栈上，则```ance```值等于```this```)
3. 所有类都实现```LinkAnce```方法，用于传递和更新后续引用链；引用链中若有```ChainPtr<T>```智能指针，可根据```ance```值判断是否是强引用；引用链上所有节点都必有且仅有一个强引用
4. 当堆内存申请、修改指向时，若遇到强引用则用```LinkAnce```方法向下端传递，若遇到若引用则不需要向下传递；当堆内存释放时，若遇到强引用则尝试将强引用转移智能指针“兄弟”处并向下传递，若无“兄弟”则向下删除指向的堆内存
5. 实现了c++的编译期反射，```LinkAnce```方法无需手工编写，仅需在类内调用```RTGC_AutoChainLink```宏自动实现，且在编译期实现，对性能无影响
## STL集成
* 通过特化```RTGC_AutoChainLink```宏及相关方法，已处理集成```vector```等容器，可直接使用```vector<ChainPtr<T>>```类型；
* unsorted_map、unsorted_set、tuple、pair等类型尚未支持，对其他容器提供特化用例
## 线程安全
* 使用支持原子操作的全局变量数组，当处理某个栈对象时，提供互斥修改
* 通过原子操作，在实现引用链修改时保证线程安全。原子操作时间与同时处理统一节点的线程数正相关